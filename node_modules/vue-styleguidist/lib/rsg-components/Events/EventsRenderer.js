function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

import React from 'react';
import PropTypes from 'prop-types';
import Group from 'react-group';
import Arguments from 'rsg-components/Arguments';
import Code from 'rsg-components/Code';
import JsDoc from 'rsg-components/JsDoc';
import Markdown from 'rsg-components/Markdown';
import Name from 'rsg-components/Name';
import Type from 'rsg-components/Type';
import Para from 'rsg-components/Para';
import Table from 'rsg-components/Table';
import map from 'lodash/map';
import { unquote, getType, showSpaces } from '../../utils/utils';

function renderType(type) {
  if (!type) {
    return 'unknown';
  }

  var name = type.name;
  var names = type.names;

  if (names) {
    name = names.join('|');
  }

  switch (name) {
    case 'arrayOf':
      return "".concat(type.value.name, "[]");

    case 'objectOf':
      return "{".concat(renderType(type.value), "}");

    case 'instanceOf':
      return type.value;

    default:
      return name;
  }
}

function renderEnum(prop) {
  if (!Array.isArray(getType(prop).value)) {
    return React.createElement("span", null, getType(prop).value);
  }

  var values = getType(prop).value.map(function (_ref) {
    var value = _ref.value;
    return React.createElement(Code, {
      key: value
    }, showSpaces(unquote(value)));
  });
  return React.createElement("span", null, "One of:", ' ', React.createElement(Group, {
    separator: ", ",
    inline: true
  }, values));
}

function renderShape(props) {
  var rows = [];

  for (var name in props) {
    var prop = props[name];
    var description = prop.description;
    rows.push(React.createElement("div", {
      key: name
    }, React.createElement(Name, null, name), ': ', React.createElement(Type, null, renderType(prop)), description && ' â€” ', description && React.createElement(Markdown, {
      text: description,
      inline: true
    })));
  }

  return rows;
}

function renderDescription(prop) {
  var description = prop.description,
      _prop$tags = prop.tags,
      tags = _prop$tags === void 0 ? {} : _prop$tags;
  var extra = renderExtra(prop);

  var args = _toConsumableArray(tags.arg || []).concat(_toConsumableArray(tags.argument || []), _toConsumableArray(tags.param || []));

  return React.createElement("div", null, description && React.createElement(Markdown, {
    text: description
  }), extra && React.createElement(Para, null, extra), React.createElement(JsDoc, tags), args.length > 0 && React.createElement(Arguments, {
    args: args,
    heading: true
  }));
}

function renderExtra(prop) {
  var type = getType(prop);

  if (!type) {
    return null;
  }

  switch (type.name) {
    case 'enum':
      return renderEnum(prop);

    case 'union':
      return renderUnion(prop);

    case 'shape':
      return renderShape(prop.type.value);

    case 'arrayOf':
      if (type.value.name === 'shape') {
        return renderShape(prop.type.value.value);
      }

      return null;

    case 'objectOf':
      if (type.value.name === 'shape') {
        return renderShape(prop.type.value.value);
      }

      return null;

    default:
      return null;
  }
}

function renderUnion(prop) {
  if (!Array.isArray(getType(prop).value)) {
    return React.createElement("span", null, getType(prop).value);
  }

  var values = getType(prop).value.map(function (value, index) {
    return React.createElement(Type, {
      key: "".concat(value.name, "-").concat(index)
    }, renderType(value));
  });
  return React.createElement("span", null, "One of type:", ' ', React.createElement(Group, {
    separator: ", ",
    inline: true
  }, values));
}

function renderName(prop) {
  var name = prop.name,
      _prop$tags2 = prop.tags,
      tags = _prop$tags2 === void 0 ? {} : _prop$tags2;
  return React.createElement(Name, {
    deprecated: !!tags.deprecated
  }, name);
}

function renderTypeColumn(prop) {
  return React.createElement(Type, null, renderType(getType(prop)));
}

export function getRowKey(row) {
  return row.name;
}
export function propsToArray(props) {
  return map(props, function (prop, name) {
    return _objectSpread({}, prop, {
      name: name
    });
  });
}
export var columns = [{
  caption: 'Event name',
  render: renderName
}, {
  caption: 'Type',
  render: renderTypeColumn
}, {
  caption: 'Description',
  render: renderDescription
}];
export default function EventsRenderer(_ref2) {
  var props = _ref2.props;
  return React.createElement(Table, {
    columns: columns,
    rows: propsToArray(props),
    getRowKey: getRowKey
  });
}
EventsRenderer.propTypes = {
  props: PropTypes.object.isRequired
};